program runtests
  !! A command line TAP consumer program, that works as a simple test harness
  !! for bare needs.
  !!
  !! Basic use:
  !!  `runtest test_program_1 test_program_2 .. test_program_n`
  !!
  !! `runtest` will execute test programs 1 .. n one by one and accumulate test
  !! results from the TAP streams generated by each program. Printing a neat
  !! summary at the end, indicating whether testing PASSed or FAILed.
  !!
  !! Perl's prove(1) can also be used for now as long as one
  !! remember to let the test programs have the suffix ".t"
  !!
  !! @Todo: (1) Collect test program names, and line them up nicely with dots
  !!        (2) Read test stream from input_unit by default on 0 arguments
  !!        (3) Show tests or other options?
  use, intrinsic :: iso_fortran_env, only: error_unit, int64, real64
  implicit none

  character(:), allocatable :: testprogram
  character                 :: path_sep
  integer                   :: i, argstatus, arglen
  integer                   :: total_tests, total_skipped
  integer                   :: total_todos, total_unexptodos
  integer                   :: total_planned, total_failed
  integer                   :: ntests, nskipped
  integer                   :: ntodos, nunexptodos
  integer                   :: nplanned, nfailed
  integer                   :: nfiles
  real(real64)              :: t1, time


  ! initialize
  total_tests = 0
  total_todos = 0
  total_unexptodos = 0
  total_skipped = 0
  total_planned = 0
  total_failed = 0
  time = 0._real64

  path_sep = get_path_sep()

  ! get number of test programs
  nfiles = command_argument_count()

  t1 = get_walltime()
  do i = 1, nfiles
    ! determine test program length
    call get_command_argument(i, length=arglen)
    if (allocated(testprogram)) deallocate(testprogram)
    allocate(character(arglen) :: testprogram)

    ! get test program name
    call get_command_argument(i, testprogram, status=argstatus)
    if (argstatus /= 0) then
      write (error_unit, '("runtests: ")', advance="NO")
      write (error_unit, '("Cannot retrieve argument no. ",I0)') i
      write (error_unit, '("          ")', advance="NO")
      write (error_unit, '("Argument status is ",I2)') argstatus
      error stop
    end if

    ! run test program
    call runtest(testprogram)
  end do
  time = get_walltime() - t1

  ! ...

  write (*, '("--------------------------------------------------")')
  write (*, '("      Files:    ",I0)') nfiles
  write (*, '("      Planned:  ",I0," (ran ",I0,")")') &
        & total_planned, total_tests
  write (*, '("      Skipped:  ",I0)') total_skipped
  write (*, '("      Todos:    ",I0," (",I0," unexpectedly passed)")') &
        & total_todos, total_unexptodos
  write (*, '("      Failed:   ",I0)') total_failed
  write (*, '("      OK tests: ",I0," (",I0," - ", I0, " - ", I0, ")")') &
        & total_tests - total_failed - total_skipped, &
        & total_tests, total_failed, total_skipped
  write (*, '("      Time:     ",G0," seconds")') time
  write (*, '("--------------------------------------------------")')

  if (total_failed > 0) then
     write (*, '("Result: FAIL")')
  else
     write (*, '("Result: PASS")')
  end if
  stop

contains

  subroutine runtest(testprogram)
    !! Use intrinsic `execute_command_line()` to run a test program, redirecting
    !! its output to a file for analysis

    ! Arguments
    character(*), intent(in) :: testprogram
    !! (relative) path to test program

    ! Local variables
    character(:), allocatable  :: t
    !! test program with any trailing whitespace removed

    character(:), allocatable  :: testoutput
    !! filename for test program output (testprogram.testoutput)

    integer                    :: stat
    !! integer status

    allocate(t, source=trim(testprogram))
    allocate(testoutput, source=t//".testoutput")
    call execute_command_line("." // path_sep // t // " > " // testoutput, &
                            & wait=.true., exitstat=stat)
    ! '>>' appends output from a command to a specified file.
    ! It works the same in both MS-DOS, PC-DOS, Unix, and Mac OS X.
    ! If the filename does not exist, it is created.
    if (stat /= 0) then
      write (*, '("ERROR! Failed to run: ",A)') t
    else
      call analyze(t, testoutput)
    end if
  end subroutine runtest

  subroutine analyze(testprogram, testoutput)
    !! Analyze the TAP output created by a test program in the plain text test
    !! output file

    ! Arguments
    character(len=*), intent(in) :: testprogram
    !! (relative) path to test program

    character(len=*), intent(in) :: testoutput
    !! (relative) path to test output

    ! Local variables
    character(200)             :: testline
    !! single line of the test output file

    character(30)              :: testprogram_dots
    !! dots for spacing output

    character(:), allocatable  :: msg
    !! error message

    integer                    :: fid
    !! file unit number (for opening test output)

    integer                    :: stat
    !! integer status

    testprogram_dots = repeat(".", len(testprogram_dots))
    testprogram_dots(1:min(len(testprogram), 30)) = testprogram
    write (*, '(A, ": ")', advance="NO") testprogram_dots

    ntests = 0
    ntodos = 0
    nunexptodos = 0
    nskipped = 0
    nplanned = 0
    nfailed = 0

    allocate(msg, source=" ")
    open(newunit=fid, file=testoutput, status='OLD', iostat=stat, iomsg=msg)
    if (stat /= 0) then
      write (*, *) "ERROR! ", msg
      close(fid)
      return
    end if

    do
      read (unit=fid, fmt='(A200)', iostat=stat, iomsg=msg) testline
      if (is_iostat_end(stat)) exit
      if (stat > 0) then ! iostat error
          msg = "ERROR READING TESTLINE! " // msg
          exit
      end if
      call analyze_line(testline, msg)
      if (msg /= "") exit ! Early exit, e.g. no plan
    end do

    ! close AND DELETE test output
    close(fid, status='DELETE')

    if (msg /= "") then
      write (*, *) msg
    else
      if (nfailed > 0) write (*, '(A)', advance="NO") "not "
      write (*, '(A)', advance="NO") "ok"

      if (nplanned /= ntests) then
          write (*, '(A,I0,A,I0)', advance="NO") &
          & "; mismatch of planned and runned tests - planned ", &
          & nplanned, ", but ran ", ntests
      end if
      if (nfailed > 0) then
          write (*, '("; ",I0,"/",I0," failed")', advance="NO") &
                  & nfailed, ntests
      end if
      if (nunexptodos > 0 .or. ntodos > 0) then
          write (*, '("; ",I0,"/",I0," todos")', advance="NO") &
                  & ntodos - nunexptodos, ntodos
      end if
      if (nskipped > 0) then
          write (*, '("; ",I0," skipped")', advance="NO") nskipped
      end if
      ! if (nunexptodos > 0) &
      !     & write (*, '(A,I0,A)', advance="NO") "; ", nunexptodos, &
      !     & " todos unexpectedly passed"
      ! if (nskipped > 0) &
      !     & write (*, '(A,I0,A)', advance="NO") "; ", nskipped, " skipped"
      ! if (ntodos > 0) &
      !     & write (*, '(A,I0,A)', advance="NO") "; ", ntodos, " todos"
      write (*, *) ""
    end if

    total_tests = total_tests + ntests
    total_todos = total_todos + ntodos
    total_unexptodos = total_unexptodos + nunexptodos
    total_skipped = total_skipped + nskipped
    total_planned = total_planned + nplanned
    total_failed = total_failed + nfailed
  end subroutine analyze

  subroutine analyze_line(testline, msg)
    !! Parse a single line of text of TAP output, ignoring comments/notes,
    !! returning early in case of errors, and otherwise incrementing test status
    !! counters

    ! Arguments
    character(len=*), intent(in) :: testline
    !! line of text from test output

    character(len=:), allocatable, intent(out) :: msg
    !! descriptive error message

    if (testline(1:1) == "#") then
      msg = ""
      return
    else if (testline(:9) == "Bail out!") then
      msg = "Bail out!"
      return
    else if (testline(:4) == "1..0") then
      msg = "No plan!"
      if (index(testline, "Skipped") > 0) msg = "Skipped!"
      return
    else if (testline(:3) == "1..") then
      if (nplanned > 0) then
          msg = "Double plan!"
          return
      end if
      read (testline(4:), *) nplanned
    end if

    msg = ""
    if (testline(1:2) == "ok") then
      ntests = ntests + 1
      if (index(testline, "SKIP") > 0) then
          nskipped = nskipped + 1
      else if (index(testline, "TODO") > 0) then
          nunexptodos = nunexptodos + 1
      end if
    else if (testline(1:6) == "not ok") then
      ntests = ntests + 1
      if (index(testline, "SKIP") > 0) then
          nskipped = nskipped + 1
      else if (index(testline, "TODO") > 0) then
          ntodos = ntodos + 1
      else
          nfailed = nfailed + 1
      end if
    end if
  end subroutine analyze_line

  function get_walltime() result(wctime)
    !! A very simple wrapper for system_clock() to use as wall clock timer.
    !! Based on: https://stackoverflow.com/a/53979065

    ! Local variables
    real(real64)    :: wctime   !! wall clock time
    integer(int64)  :: counter  !! system clock counter
    integer(int64)  :: rate     !! system clock rate

    call system_clock(counter, rate)
    wctime = real(counter, real64) / rate
  end function get_walltime

  function get_path_sep() result(sep)
    !! get the path separator (i.e. `/` or `\)`used by the current OS, by
    !! querying the PATH environment variable using the
    !! `get_environment_variable()` intrinsic.
    !!
    !! This may not be entirely reliable, read the discussion
    !! [here](https://duckduckgo.com/?q=querying&atb=v181-1&ia=web) for details

    character                  :: sep
    !! function result, the path separator used by current OS

    ! Local variables
    character(:), allocatable  :: path
    !! variable to hold the PATH environment variable

    integer                    :: path_length
    !! length of the PATH environment variable

    integer                    :: status

    ! Default to Linux, OS X, WSL, ... type path separator
    sep = "/"

    !
    call get_environment_variable("PATH", length=path_length)
    allocate(character(path_length) :: path)

    call get_environment_variable("PATH", value=path, status=status)
    if (status /= 0) then
      write(error_unit, '(*(/,a))') &
        "Could not get OS's PATH environment variable", &
        "Unable to determine path separator", &
        "Assuming it is *nix like: '/' ..."
      return
    end if

    if (path(1:1) /= sep) then
      ! seems like we're on Windows instead...
      sep = "\"
    end if
  end function get_path_sep

end program runtests